// Generated by CoffeeScript 1.6.3
(function() {
  var Coffee, Compilers, Tintan, btoa, coffee, compilerMap, fs, path, spawn, touch,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  require('colors');

  fs = require('fs');

  path = require('path');

  btoa = require('btoa');

  coffee = require('coffee-script');

  spawn = require('child_process').spawn;

  touch = require('touch');

  Tintan = null;

  compilerMap = function(root, rexp, transform, base, map) {
    var dir;
    if (transform == null) {
      transform = (function(i) {
        return i;
      });
    }
    if (base == null) {
      base = [];
    }
    if (map == null) {
      map = {};
    }
    dir = path.join.apply(path, [root].concat(base));
    fs.existsSync(dir) && fs.readdirSync(dir).forEach(function(f) {
      if (fs.statSync(path.join(dir, f)).isDirectory()) {
        return compilerMap(root, rexp, transform, base.concat(f), map);
      } else if (rexp.test(f)) {
        return map[path.join(dir, f)] = transform(path.join.apply(path, base.concat([f])));
      }
    });
    return map;
  };

  Coffee = (function() {
    var DEFAULT_OPTIONS;

    function Coffee() {
      this.compile = __bind(this.compile, this);
    }

    DEFAULT_OPTIONS = {
      src: 'src/coffee',
      target: 'Resources',
      ext: '\.(coffee|iced)$',
      name: 'compile:coffee'
    };

    Coffee.prototype.init = function(tintan, options) {
      var c, compile, compiled, from, k, map, s, sources, target, v,
        _this = this;
      this.options = options != null ? options : {};
      for (k in DEFAULT_OPTIONS) {
        v = DEFAULT_OPTIONS[k];
        if (!this.options.hasOwnProperty(k)) {
          this.options[k] = v;
        }
      }
      if (typeof this.options.ext === 'string') {
        this.options.ext = new RegExp(this.options.ext);
      }
      options = this.options;
      from = Tintan.$._(options.src);
      target = Tintan.$._(options.target);
      map = this.map = compilerMap(from, options.ext, function(f) {
        return path.join(target, f).replace(options.ext, '.js');
      });
      compile = this.compile;
      sources = (function() {
        var _results;
        _results = [];
        for (s in map) {
          _results.push(s);
        }
        return _results;
      })();
      if (sources.length === 0) {
        return false;
      }
      compiled = (function() {
        var _results;
        _results = [];
        for (s in map) {
          c = map[s];
          _results.push(c);
        }
        return _results;
      })();
      for (s in map) {
        c = map[s];
        file(c, [s], {
          async: true
        }, function() {
          return compile(this.prereqs[0], this.name, complete);
        });
      }
      Tintan.$.onTaskNamespace(options.name, function(name) {
        desc("Compile coffee-script sources into " + options.target);
        return task(name, compiled, function() {
          return console.log('compiled'.green + ' coffee-script sources into ' + options.target);
        });
      });
      Tintan.$.onTaskNamespace(options.name + ':force', function() {
        desc("Compile all coffee-script (regardless of mod time) into " + options.target);
        return task('force', function() {
          var source, task, _results;
          _results = [];
          for (source in map) {
            task = map[source];
            _results.push((function(task) {
              return touch(source, {
                mtime: true
              }, function() {
                return invoke(task);
              });
            })(task));
          }
          return _results;
        });
      });
      Tintan.$.onTaskNamespace(options.name + ':dist', function() {
        desc("Compile all coffee-script for distribution (no source maps) into " + options.target);
        return task('dist', function() {
          jake.program.envVars['source_maps'] = false;
          return invoke("" + options.name + ":force");
        });
      });
      Tintan.$.onTaskNamespace(options.name + ':clean', function() {
        desc("Clean coffee-script produced files from " + options.target);
        return task('clean', function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = compiled.length; _i < _len; _i++) {
            c = compiled[_i];
            _results.push(fs.unlink(c));
          }
          return _results;
        });
      });
      Tintan.$.onTaskNamespace(options.name + ':watch', function() {
        return watchTask('watch', 'compile:coffee', function() {
          return this.watchFiles.include([options.ext]);
        });
      });
      return true;
    };

    Coffee.prototype.compile = function(source, target, cb) {
      var c, compileOpts, conf, err, iced, j, jsm, relativeSource, sm;
      jake.file.mkdirP(path.dirname(target));
      c = fs.readFileSync(source, 'utf-8');
      try {
        conf = Tintan.config();
        iced = conf.envOrGet('iced');
        if (iced === true) {
          coffee = require('iced-coffee-script');
        }
        if (conf.envOrGet('verbose') === true) {
          console.log('Compiling ' + target + ' with ' + (iced ? 'iced-' : '') + 'coffee-script');
        }
        if (conf.envOrGet('source_maps') === true) {
          relativeSource = this.options.src + source.split(this.options.src).slice(-1)[0];
          compileOpts = {
            sourceMap: true,
            filename: source,
            sourceFiles: ['file://' + process.cwd() + '/' + relativeSource],
            generatedFile: this.options.target + target.split(this.options.target).slice(-1)[0]
          };
          jsm = coffee.compile(c, compileOpts);
          j = jsm.js;
          sm = jsm.v3SourceMap;
          j = "" + j + "\n";
          j += "//# sourceMappingURL=data:application/json;base64," + (btoa(unescape(encodeURIComponent(sm)))) + "\n";
          j += "//# sourceURL=" + relativeSource;
        } else {
          j = coffee.compile(c);
        }
        fs.writeFileSync(target, j, 'utf-8');
      } catch (_error) {
        err = _error;
        process.stderr.write("Error compiling " + source + "\n");
        process.stderr.write(err.toString() + "\n");
        fail("Error compiling " + source + "\n");
      }
      return cb();
    };

    Coffee.prototype.invokeTask = function() {
      return invoke(this.options.name);
    };

    Coffee.prototype.invokeClean = function() {
      return invoke(this.options.name + ':clean');
    };

    return Coffee;

  })();

  Compilers = {
    coffee: Coffee
  };

  module.exports = function(tintan) {
    var compilers;
    Tintan = tintan.constructor;
    compilers = [];
    Tintan.$.onTaskNamespace('compile', function(name) {
      desc('Compile sources');
      return task(name, function() {
        var compiler, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = compilers.length; _i < _len; _i++) {
          compiler = compilers[_i];
          _results.push(compiler.invokeTask());
        }
        return _results;
      });
    });
    Tintan.$.onTaskNamespace('compile:dist', function() {
      desc('Compile sources for distribution');
      return task('dist', function() {
        var compiler, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = compilers.length; _i < _len; _i++) {
          compiler = compilers[_i];
          _results.push(invoke("" + compiler.options.name + ":dist"));
        }
        return _results;
      });
    });
    return tintan.compile = function() {
      var Compiler, args, compiler, lang;
      lang = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      Compiler = Compilers[lang];
      if (!Compiler) {
        fail(("Dont know how to compile " + lang).red);
      }
      compiler = new Compiler;
      if (compiler.init.apply(compiler, [tintan].concat(args))) {
        return compilers.push(compiler);
      }
    };
  };

}).call(this);

/*
//@ sourceMappingURL=compile.map
*/
